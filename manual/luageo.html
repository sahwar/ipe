<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Ipelib: Lua bindings for geometric objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Ipelib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">The Ipe library documentation</a></li><li class="navelem"><a class="el" href="lua.html">Programming in Lua</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Lua bindings for geometric objects </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>All Ipelib objects have constructors of the form:</p>
<pre class="fragment"> v = ipe.Vector()
 m = ipe.Matrix()
 m = ipe.Translation()  -- another Matrix constructor
 m = ipe.Rotation()     -- yet another Matrix constructor
 r = ipe.Rect()
 l = ipe.Line()
 l = ipe.LineThrough()  -- another Line constructor
 l = ipe.Bisector()     -- yet another Line constructor
 s = ipe.Segment()
 b = ipe.Bezier()
 a = ipe.Arc()
</pre><p>Note that <a class="el" href="classipe_1_1_angle.html" title="A double that&#39;s an angle. ">ipe::Angle</a> and <a class="el" href="classipe_1_1_linear.html" title="Linear transformation in the plane (2x2 matrix). ">ipe::Linear</a> are not bound in Lua. Use numbers and <a class="el" href="classipe_1_1_matrix.html" title="Homogeneous transformation in the plane. ">ipe.Matrix</a> instead. A useful method for angles is: </p><pre class="fragment">beta = ipe.normalizeAngle(alpha, lowLimit)
</pre><h1><a class="anchor" id="luavector"></a>
Vector</h1>
<p><em><a class="el" href="classipe_1_1_vector.html" title="Two-dimensional vector. ">ipe.Vector</a></em> binds <a class="el" href="classipe_1_1_vector.html" title="Two-dimensional vector. ">ipe::Vector</a>. There are the following methods: </p><pre class="fragment">v = ipe.Vector()         -- zero vector
v = ipe.Vector(x, y)
v = ipe.Direction(alpha) -- unit vector in this direction 
a = v.x                  -- read only access to x and y coordinates
b = v.y

v:len() -- returns norm of vector
v:sqLen() -- returns square of norm
v:normalized() -- returns this vector normalized
v:orthogonal() -- returns this vector rotated left by 90 degrees
v:factorize(u) -- factors v = lambda u + x, where x orth. to u, u is unit
v:angle()     -- return direction 
v == w        -- vector equality
v ~= w
-v            -- unary minus
v + w         -- vector addition
v - w         -- vector difference
5 * v         -- multiplication with a scalar
v * 5         -- multiplication with a scalar
v .. w        -- dot product
</pre><h1><a class="anchor" id="luamatrix"></a>
Matrix</h1>
<p><em><a class="el" href="classipe_1_1_matrix.html" title="Homogeneous transformation in the plane. ">ipe.Matrix</a></em> binds <a class="el" href="classipe_1_1_matrix.html" title="Homogeneous transformation in the plane. ">ipe::Matrix</a>. It has the following methods: </p><pre class="fragment">m = ipe.Matrix()                        -- identity matrix
m = ipe.Matrix(a1, a2, a3, a4)          -- linear transformation
m = ipe.Matrix(a1, a2, a3, a4, a5, a6)  -- affine transformation
m = ipe.Matrix( { a1, a2, a3, a4, a5, a6 } ) -- same from table
m = ipe.Rotation(alpha)                 -- rotation matrix
m = ipe.Translation(v)                  -- v is a vector
m = ipe.Translation(x, y)

m1 == m2          -- matrix equality
m1 * m2           -- matrix multiplication
m * v             -- matrix * vector
m * arc           -- matrix * arc

m:elements()      -- returns six-element array with elements

m:isIdentity()
m:isSingular()
m:inverse()
m:translation()   -- return translation component
m:linear()        -- returns matrix without the translation component
</pre><h1><a class="anchor" id="luarect"></a>
Rect</h1>
<p><em><a class="el" href="classipe_1_1_rect.html" title="Axis-parallel rectangle (which can be empty) ">ipe.Rect</a></em> binds <a class="el" href="classipe_1_1_rect.html" title="Axis-parallel rectangle (which can be empty) ">ipe::Rect</a>. This is the only mutable geometric object - take care not to be surprised when <em><a class="el" href="classipe_1_1_rect.html" title="Axis-parallel rectangle (which can be empty) ">ipe.Rect</a></em> objects are shared.</p>
<p>It has the following methods: </p><pre class="fragment">r = ipe.Rect()    -- empty
r:isEmpty()
r:topRight()
r:bottomLeft()
r:topLeft()
r:bottomRight()
r:left()
r:right()
r:bottom()
r:top()
r:width()
r:height()
r:add(v)          -- extend to cover vector v
r1:add(r2)        -- extend to cover rectangle r2
r1:clipTo(r2)     -- clip r1 to lie inside r2
r:contains(v)     
r1:contains(r2)
r1:intersects(r2)
</pre><h1><a class="anchor" id="lualine"></a>
Line</h1>
<p><em><a class="el" href="classipe_1_1_line.html" title="A directed line. ">ipe.Line</a></em> binds <a class="el" href="classipe_1_1_line.html" title="A directed line. ">ipe::Line</a>. It has the following methods:</p>
<pre class="fragment">l = ipe.Line(p, dir)      -- dir must be unit vector
l = ipe.LineThrough(p, q)
l = ipe.Bisector(p, q)

-- l:side() returns +1 if v lies to the left side of the line, 
-- 0 if on line, -1 if on the right side
l:side(v)                 
l:point()                 -- starting point of line
l:dir()                   -- unit direction vector
l:normal()                -- unit normal vector pointing to the left side
l:distance(v)             -- returns distance from point to line
l1:intersects(l2)         -- returns intersection point or nil
l:project(p)              -- projection of point on line
</pre><h1><a class="anchor" id="luasegment"></a>
Segment</h1>
<p><em><a class="el" href="classipe_1_1_segment.html" title="A directed line segment. ">ipe.Segment</a></em> binds <a class="el" href="classipe_1_1_segment.html" title="A directed line segment. ">ipe::Segment</a>. It has the following methods:</p>
<pre class="fragment">s = ipe.Segment(p, q)   
p, q = s:endpoints()      -- returns both endpoints
s:line()                  -- returns an ipe.Line
s:project(p)              -- returns projection or nil
s:distance(p)
s:intersects(l)           -- return intersection point or nil
s1:intersects(s2)
</pre><h1><a class="anchor" id="luabezier"></a>
Bezier</h1>
<p><em><a class="el" href="classipe_1_1_bezier.html" title="A cubic Bezier spline. ">ipe.Bezier</a></em> binds <a class="el" href="classipe_1_1_bezier.html" title="A cubic Bezier spline. ">ipe::Bezier</a>. It has the following methods:</p>
<pre class="fragment">b = ipe.Bezier(v1, v2, v3, v4)  
b:point(t)                -- point at value t
v1, v2, v3, v4 = b:controlpoints()  -- returns all four control points
b:bbox()
t, p = b:snap(pos)
b:intersects(s)           -- return intersection point or nil
b:intersects(l)
</pre><h1><a class="anchor" id="luaarc"></a>
Arc</h1>
<p><em><a class="el" href="classipe_1_1_arc.html" title="An arc of an ellipse. ">ipe.Arc</a></em> binds <a class="el" href="classipe_1_1_arc.html" title="An arc of an ellipse. ">ipe::Arc</a>. It has the following methods:</p>
<pre class="fragment">a = ipe.Arc(m)            -- ellipse defined by ipe.Matrix m
a = ipe.Arc(m, p, q)      -- arc from p to q
a = ipe.Arc(m, alpha, beta)

a:endpoints()             -- returns two endpoints
a:angles()                -- returns two angles
a:bbox()
a:matrix()
a:isEllipse() 
alpha, p = a:snap(pos)
a:intersects(s)           -- return intersection point or nil
a:intersects(l)
</pre> </div></div><!-- contents -->
<hr>
</body></html>
